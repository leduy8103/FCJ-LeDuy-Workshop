[
{
	"uri": "http://localhost:1313/en/1-introduction/",
	"title": "Chapter 1: Overview Introduction",
	"tags": [],
	"description": "",
	"content": "Workshop Goals In this workshop, you will learn how to deploy a multi-container application (frontend + backend) to AWS ECS Fargate. Main objectives:\nUnderstand the basic CI/CD process. Dockerize frontend and backend applications. Use AWS services like ECR, ECS Fargate, and CloudWatch. Key Steps Learn about CI/CD and containerization. Dockerize frontend and backend applications. Push container images to Amazon ECR. Deploy containers to ECS Fargate. Automate the process with GitHub Actions. Core DevOps Knowledge CI/CD CI/CD (Continuous Integration/Continuous Deployment) is the process of automating source code integration and deployment. It helps minimize errors and accelerate software development.\nContinuous Integration: Regularly integrate source code to detect errors early. Continuous Deployment: Automatically deploy source code after successful testing. Example: Every time you push to the main branch, GitHub Actions will automatically perform steps: build image, push to ECR, and deploy to ECS Fargate. Containerization Containerization is the technique of packaging applications and their dependencies into a container. Docker is the most popular tool to accomplish this.\nBenefits: Easy deployment, consistency across environments. Tools: Docker, Kubernetes. ECS Fargate ECS Fargate is an AWS service that helps run containers without managing servers.\nBenefits: No need to manage infrastructure. Application: Run containerized applications. Technologies Used GitHub Actions: Automate CI/CD processes. This workshop uses GitHub Actions instead of AWS CodePipeline because it\u0026rsquo;s more accessible to beginners. Docker: Package applications. Amazon ECR: Store container images. Amazon ECS Fargate: Run containers. CloudWatch: Monitor logs and system status. Overall Architecture Below is the overall system architecture diagram:\nFrontend: React app. Backend: Node.js or Flask app. ECR: Store container images. ECS Fargate: Run containers. Application Load Balancer: Distribute traffic. CloudWatch: Log and monitor. Tip: Make sure you have an AWS account and understand the basics of AWS services before starting.\n"
},
{
	"uri": "http://localhost:1313/en/",
	"title": "Workshop: Deploy applications with ECS Fargate and CI/CD",
	"tags": [],
	"description": "",
	"content": "Workshop: Deploy applications with ECS Fargate and CI/CD Welcome to the workshop on deploying multi-container applications to AWS ECS Fargate with automated CI/CD processes. In this workshop, you will learn how to:\nDockerize frontend and backend applications Use Amazon ECR to store container images Deploy containers to ECS Fargate Set up monitoring with CloudWatch Automate the entire process with GitHub Actions Workshop Objectives After completing this workshop, you will be able to:\nUnderstand basic CI/CD processes Master using Docker for containerization Deploy applications to AWS ECS Fargate Set up monitoring and logging Automate deployment with GitHub Actions Prerequisites Basic understanding of AWS Experience with Docker Understanding of Git and GitHub Basic knowledge of CI/CD Estimated Time This workshop will take approximately 2-3 hours to complete.\nSystem Architecture The system includes:\nFrontend: React application Backend: Node.js/Flask application ECR: Container registry ECS Fargate: Container orchestration CloudWatch: Monitoring and logging GitHub Actions: CI/CD pipeline "
},
{
	"uri": "http://localhost:1313/en/2-dockerize/",
	"title": "Chapter 2: Project Preparation &amp; Application Dockerization",
	"tags": [],
	"description": "",
	"content": "Initial Assumptions You already have source code for frontend (React) and backend (Node.js or Flask) applications in the same repository. Clone repository from GitHub: # Clone repository containing both frontend and backend git clone https://github.com/leduy8103/ecs-cicd-workshop.git Check Dockerfile Dockerfile for Frontend (React) # Use Node.js image FROM node:16 # Set working directory WORKDIR /app # Copy package.json and install dependencies COPY package.json ./ RUN npm install # Copy entire source code COPY . . # Build application RUN npm run build # Use Nginx image to serve the application FROM nginx:alpine COPY --from=0 /app/build /usr/share/nginx/html # Expose port EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] Dockerfile for Backend (Node.js) # Use Node.js image FROM node:16 # Set working directory WORKDIR /app # Copy package.json and install dependencies COPY package.json ./ RUN npm install # Copy entire source code COPY . . # Expose port EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] Tip: Make sure the Dockerfile has been tested and works properly before proceeding.\n"
},
{
	"uri": "http://localhost:1313/en/3-ecr/",
	"title": "Chapter 3: Create ECR repositories and push images",
	"tags": [],
	"description": "",
	"content": "Create repository in Amazon ECR Steps to follow Access AWS Management Console. Navigate to ECR (Elastic Container Registry). Create 2 repositories: frontend-app backend-app Tip: Name repositories clearly for easy management.\nBuild and push images to ECR Using GitHub Actions Create file .github/workflows/deploy.yml name: Build and Push to ECR on: push: branches: - main jobs: build-and-push: runs-on: ubuntu-latest env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Checkout code uses: actions/checkout@v3 - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v1 with: aws-region: ${{ env.AWS_REGION }} - name: Build frontend image run: | docker build -t frontend-app ./frontend-app docker tag frontend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Push frontend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Build backend image run: | docker build -t backend-app ./backend-app docker tag backend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Push backend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActionsRole aws-region: ${{ env.AWS_REGION }} Set up secrets on GitHub To use secrets in GitHub Actions, you need to set up secrets in your repository.\nSteps to follow Access your repository on GitHub. Navigate to Settings \u0026gt; Secrets and variables \u0026gt; Actions. Click New repository secret to add new secrets.\nAdd the necessary secrets:\nAWS_REGION: Your AWS region (e.g., ap-southeast-1). AWS_ACCOUNT_ID: Your AWS account ID. AWS_ACCESS_KEY_ID: Access key ID of IAM user or role. AWS_SECRET_ACCESS_KEY: Secret access key of IAM user or role. Warning: Make sure these secrets are secure and not shared publicly.\nUsing secrets in workflow In the workflow file .github/workflows/deploy.yml, you can access secrets using the syntax secrets.\u0026lt;SECRET_NAME\u0026gt;.\nExample:\nenv: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} Using AWS CLI Login to ECR aws ecr get-login-password --region \u0026lt;AWS_REGION\u0026gt; | docker login --username AWS --password-stdin \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com Build and push images # Frontend docker build -t frontend-app ./frontend-app docker tag frontend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest # Backend docker build -t backend-app ./backend-app docker tag backend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Check results Access AWS Management Console to verify images have been pushed to repositories. Ensure images have latest tag and correct format. "
},
{
	"uri": "http://localhost:1313/en/4-deploy-ecs-fargate/",
	"title": "Chapter 4: Deploy ECS Fargate",
	"tags": [],
	"description": "",
	"content": "Chapter Objectives In this chapter, you will learn how to deploy dockerized frontend and backend applications pushed to ECR using Amazon ECS Fargate ‚Äì a serverless container service on AWS.\nStep 1: Create ECS Cluster Access AWS Console ‚Üí find ECS Select Clusters ‚Üí click Create Cluster Choose cluster type: Networking only (Fargate) Name: workshop-cluster-81 Click Create ‚úÖ The cluster will have no EC2 instances because you\u0026rsquo;re using Fargate (serverless).\nStep 2: Create Task Definition You need to create 2 task definitions ‚Äì one for frontend and one for backend.\n2.1. Frontend Task ECS ‚Üí Task Definitions ‚Üí Create new Task Definition Launch type: Fargate Task name: frontend-task CPU: 0.5 vCPU, Memory: 1 GB Click Add container:\nContainer name: frontend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest Port mappings: 80 Click Create\n2.2. Backend Task Repeat the above steps with:\nTask name: backend-task Container name: backend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Port mappings: 3000 ‚úÖ Successfully created backend-task and frontend-task. Step 3: Create VPC and Networking If you don\u0026rsquo;t have a suitable VPC, create one following these steps:\nAccess VPC ‚Üí Create VPC Name: workshop-vpc, CIDR block: 10.0.0.0/16 Create 2 subnets: Subnet 1: 10.0.1.0/24 ‚Äì Public Subnet 2: 10.0.2.0/24 ‚Äì Private Create Internet Gateway ‚Üí attach to workshop-vpc Update Route Table: Public Route Table: route 0.0.0.0/0 to Internet Gateway Assign this route table to Subnet 1 ‚ö†Ô∏è Only frontend needs internet access (public subnet). Backend can be placed in private subnet.\nStep 4: Create Security Group Go to EC2 ‚Üí Security Groups ‚Üí Create Security Group Name: frontend-sg, description: Allow HTTP Inbound rules: Type: HTTP Port: 80 Source: 0.0.0.0/0 Outbound: keep default (Allow all) Create additional backend-sg:\nInbound: Type: Custom TCP, Port 3000 Source: frontend-sg (select from group list) Outbound: default Step 5: Create ECS Service (run containers) 5.1. Create Frontend Service Go to ECS ‚Üí workshop-cluster Select Services tab ‚Üí Create Fill information: Launch type: Fargate Task definition: frontend-task Service name: frontend-service Number of tasks: 1 Cluster VPC: select workshop-vpc Subnet: select public subnet Security Group: select frontend-sg Check Enable public IP Click Create Service 5.2. Create Backend Service Repeat the above steps with:\nTask: backend-task Subnet: select private subnet (or public if needed for simple demo) SG: backend-sg No public IP needed if not calling directly from browser Check deployment After creation:\nECS will run 2 tasks in 2 services. Go to ECS \u0026gt; Clusters \u0026gt; Tasks to check RUNNING status If not visible, check Security Group and ECR image push again.\n"
},
{
	"uri": "http://localhost:1313/en/5-cloudwatch/",
	"title": "Chapter 5: Monitoring with Amazon CloudWatch",
	"tags": [],
	"description": "",
	"content": "Objectives In this chapter, you will learn how to use Amazon CloudWatch to monitor the performance of containers running on ECS Fargate. Steps include:\nMonitor system metrics (CPU, memory, network) Create alarms Build visual dashboards (Optional) View logs for troubleshooting 1. Monitor metrics with CloudWatch Metrics Steps: Access AWS Console ‚Üí CloudWatch ‚Üí Metrics Find your ECS Cluster ‚Üí select metrics to monitor: Metric Meaning CPUUtilization CPU usage percentage MemoryUtilization Memory usage 2. Create alerts with CloudWatch Alarm Example: Alert when CPU \u0026gt; 80% for 5 minutes Go to CloudWatch ‚Üí Alarms ‚Üí Create Alarm Select metric: CPUUtilization Select cluster ‚Üí service to monitor Set conditions: Threshold: Greater than 80 Evaluation: 5 minutes Optional: send alerts via SNS or email Preview configuration ‚Üí select \u0026ldquo;Create Alarm\u0026rdquo; Tip: Create additional alarms for MemoryUtilization if you suspect memory leaks.\n3. Create overall monitoring dashboard Go to CloudWatch ‚Üí Dashboards ‚Üí Create Dashboard Name example: ecs-monitoring-dashboard Add the following widgets: Widget Type CPUUtilization (FE + BE) Line graph MemoryUtilization Line graph Alarm status Text or Alarm widget Save and use for visual monitoring 4. Check container logs If you need to check errors:\nGo to CloudWatch ‚Üí Logs ‚Üí Log groups Select log groups to view Click latest log stream ‚Üí view detailed logs üîß Log driver is configured by default in task definition from previous step.\nConclusion Using CloudWatch helps you monitor, alert, and visualize ECS service performance. This is an essential DevOps tool to ensure applications run stably and respond promptly when issues occur.\n"
},
{
	"uri": "http://localhost:1313/en/6-github-actions/",
	"title": "Chapter 6: Automate everything with GitHub Actions",
	"tags": [],
	"description": "",
	"content": "Objectives After this chapter, you will set up a CI/CD process that automates everything when pushing code to GitHub:\nBuild images for frontend and backend Push images to Amazon ECR Deploy containers to ECS Fargate Log and check status (Optional) Rollback if errors occur 1. Set up secrets in GitHub Go to GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions, add variables:\nName Value AWS_ACCESS_KEY_ID Access Key of IAM user/role AWS_SECRET_ACCESS_KEY Corresponding secret key AWS_REGION ap-southeast-1 AWS_ACCOUNT_ID AWS account ID üéØ IAM user should have permissions: AmazonEC2ContainerRegistryFullAccess, AmazonECS_FullAccess, CloudWatchLogsFullAccess\n2. Create file .github/workflows/ci-cd.yml name: CI/CD Pipeline on: push: branches: - main env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v3 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR uses: aws-actions/amazon-ecr-login@v1 - name: Build and Push Frontend Image run: | docker build -t frontend-app ./frontend docker tag frontend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest - name: Build and Push Backend Image run: | docker build -t backend-app ./backend docker tag backend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest - name: Deploy to ECS run: | aws ecs update-service --cluster workshop-cluster --service frontend-service --force-new-deployment aws ecs update-service --cluster workshop-cluster --service backend-service --force-new-deployment - name: Check ECS Service Status run: | aws ecs describe-services --cluster workshop-cluster \\ --services frontend-service backend-service 3. Logging and status checking Check container logs: Go to CloudWatch ‚Üí Log groups ‚Üí View log stream Check ECS status: aws ecs describe-services --cluster workshop-cluster --services frontend-service backend-service 4. Rollback (manual) When deployment fails, you can rollback by:\nRevert code ‚Üí Push again Or deploy old image from ECR (if tagged and saved previously) üì¶ Tip: Use tags :v1, :v2, :rollback,\u0026hellip; for easy rollback image control\n"
},
{
	"uri": "http://localhost:1313/en/7-cleanup/",
	"title": "Chapter 7: Cleanup &amp; Summary",
	"tags": [],
	"description": "",
	"content": "Cleanup Delete ECS service and task Steps to follow Access AWS Management Console.\nNavigate to ECS (Elastic Container Service).\nDelete services:\nfrontend-service backend-service Delete cluster if no longer used.\nDelete ECR images Steps to follow Access AWS Management Console. Navigate to ECR (Elastic Container Registry). Delete images in repositories: frontend-app backend-app Delete logs on CloudWatch Steps to follow Access AWS Management Console. Navigate to CloudWatch \u0026gt; Logs. Delete log groups: /aws/ecs/workshop-cluster/frontend-app /aws/ecs/workshop-cluster/backend-app Warning: Make sure you don\u0026rsquo;t need the data before deleting.\nSummary Knowledge learned Basic CI/CD process. Dockerizing frontend and backend applications. Using AWS services like ECR, ECS Fargate, and CloudWatch. Automating the entire process with GitHub Actions. Next steps Apply knowledge to real projects. Learn more about other AWS services like Lambda, API Gateway. Improve DevOps skills by deploying more complex systems. Tip: Always check AWS resources to avoid unnecessary costs.\n"
},
{
	"uri": "http://localhost:1313/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]