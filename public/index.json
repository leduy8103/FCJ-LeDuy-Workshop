[
{
	"uri": "//localhost:1313/en/",
	"title": "Workshop: Deploy applications with ECS Fargate and CI/CD",
	"tags": [],
	"description": "",
	"content": "Workshop: Deploy applications with ECS Fargate and CI/CD Welcome to the workshop on deploying multi-container applications to AWS ECS Fargate with automated CI/CD processes. In this workshop, you will learn how to:\nDockerize frontend and backend applications Use Amazon ECR to store container images Deploy containers to ECS Fargate Set up monitoring with CloudWatch Automate the entire process with GitHub Actions Workshop Objectives After completing this workshop, you will be able to:\nUnderstand basic CI/CD processes Master using Docker for containerization Deploy applications to AWS ECS Fargate Set up monitoring and logging Automate deployment with GitHub Actions Prerequisites Basic understanding of AWS Experience with Docker Understanding of Git and GitHub Basic knowledge of CI/CD Estimated Time This workshop will take approximately 2-3 hours to complete.\nSystem Architecture The system includes:\nFrontend: React application Backend: Node.js/Flask application ECR: Container registry ECS Fargate: Container orchestration CloudWatch: Monitoring and logging GitHub Actions: CI/CD pipeline "
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Workshop: Tri·ªÉn khai ·ª©ng d·ª•ng v·ªõi ECS Fargate v√† CI/CD",
	"tags": [],
	"description": "",
	"content": "Workshop: Tri·ªÉn khai ·ª©ng d·ª•ng v·ªõi ECS Fargate v√† CI/CD Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi workshop v·ªÅ tri·ªÉn khai ·ª©ng d·ª•ng multi-container l√™n AWS ECS Fargate v·ªõi quy tr√¨nh CI/CD t·ª± ƒë·ªông. Trong workshop n√†y, b·∫°n s·∫Ω h·ªçc c√°ch:\nDockerize ·ª©ng d·ª•ng frontend v√† backend S·ª≠ d·ª•ng Amazon ECR ƒë·ªÉ l∆∞u tr·ªØ container images Tri·ªÉn khai containers l√™n ECS Fargate Thi·∫øt l·∫≠p monitoring v·ªõi CloudWatch T·ª± ƒë·ªông h√≥a to√†n b·ªô quy tr√¨nh v·ªõi GitHub Actions M·ª•c ti√™u c·ªßa workshop Sau khi ho√†n th√†nh workshop n√†y, b·∫°n s·∫Ω c√≥ kh·∫£ nƒÉng:\nHi·ªÉu ƒë∆∞·ª£c quy tr√¨nh CI/CD c∆° b·∫£n Th√†nh th·∫°o vi·ªác s·ª≠ d·ª•ng Docker cho containerization Tri·ªÉn khai ·ª©ng d·ª•ng l√™n AWS ECS Fargate Thi·∫øt l·∫≠p monitoring v√† logging T·ª± ƒë·ªông h√≥a deployment v·ªõi GitHub Actions Ki·∫øn th·ª©c y√™u c·∫ßu Hi·ªÉu bi·∫øt c∆° b·∫£n v·ªÅ AWS Kinh nghi·ªám v·ªõi Docker Hi·ªÉu v·ªÅ Git v√† GitHub Ki·∫øn th·ª©c c∆° b·∫£n v·ªÅ CI/CD Th·ªùi gian d·ª± ki·∫øn Workshop n√†y s·∫Ω m·∫•t kho·∫£ng 2-3 gi·ªù ƒë·ªÉ ho√†n th√†nh.\nKi·∫øn tr√∫c h·ªá th·ªëng H·ªá th·ªëng bao g·ªìm:\nFrontend: React application Backend: Node.js/Flask application ECR: Container registry ECS Fargate: Container orchestration CloudWatch: Monitoring v√† logging GitHub Actions: CI/CD pipeline "
},
{
	"uri": "//localhost:1313/en/1-introduction/",
	"title": "üß± Chapter 1: Overview Introduction",
	"tags": [],
	"description": "",
	"content": "Workshop Goals In this workshop, you will learn how to deploy a multi-container application (frontend + backend) to AWS ECS Fargate. Main objectives:\nUnderstand the basic CI/CD process. Dockerize frontend and backend applications. Use AWS services like ECR, ECS Fargate, and CloudWatch. Key Steps Learn about CI/CD and containerization. Dockerize frontend and backend applications. Push container images to Amazon ECR. Deploy containers to ECS Fargate. Automate the process with GitHub Actions. Core DevOps Knowledge CI/CD CI/CD (Continuous Integration/Continuous Deployment) is the process of automating source code integration and deployment. It helps minimize errors and accelerate software development.\nContinuous Integration: Regularly integrate source code to detect errors early. Continuous Deployment: Automatically deploy source code after successful testing. Example: Every time you push to the main branch, GitHub Actions will automatically perform steps: build image, push to ECR, and deploy to ECS Fargate. Containerization Containerization is the technique of packaging applications and their dependencies into a container. Docker is the most popular tool to accomplish this.\nBenefits: Easy deployment, consistency across environments. Tools: Docker, Kubernetes. ECS Fargate ECS Fargate is an AWS service that helps run containers without managing servers.\nBenefits: No need to manage infrastructure. Application: Run containerized applications. Technologies Used GitHub Actions: Automate CI/CD processes. This workshop uses GitHub Actions instead of AWS CodePipeline because it\u0026rsquo;s more accessible to beginners. Docker: Package applications. Amazon ECR: Store container images. Amazon ECS Fargate: Run containers. CloudWatch: Monitor logs and system status. Overall Architecture Below is the overall system architecture diagram:\nFrontend: React app. Backend: Node.js or Flask app. ECR: Store container images. ECS Fargate: Run containers. Application Load Balancer: Distribute traffic. CloudWatch: Log and monitor. Tip: Make sure you have an AWS account and understand the basics of AWS services before starting.\n"
},
{
	"uri": "//localhost:1313/1-introduction/",
	"title": "üß± Ch∆∞∆°ng 1: Gi·ªõi thi·ªáu t·ªïng quan",
	"tags": [],
	"description": "",
	"content": "M·ª•c ti√™u workshop Trong workshop n√†y, b·∫°n s·∫Ω h·ªçc c√°ch deploy m·ªôt ·ª©ng d·ª•ng g·ªìm nhi·ªÅu container (frontend + backend) l√™n AWS ECS Fargate. M·ª•c ti√™u ch√≠nh:\nHi·ªÉu quy tr√¨nh CI/CD c∆° b·∫£n. Docker h√≥a ·ª©ng d·ª•ng frontend v√† backend. S·ª≠ d·ª•ng c√°c d·ªãch v·ª• AWS nh∆∞ ECR, ECS Fargate, v√† CloudWatch. C√°c b∆∞·ªõc ch√≠nh T√¨m hi·ªÉu v·ªÅ CI/CD v√† containerization. Docker h√≥a ·ª©ng d·ª•ng frontend v√† backend. ƒê·∫©y container image l√™n Amazon ECR. Deploy container l√™n ECS Fargate. T·ª± ƒë·ªông h√≥a quy tr√¨nh v·ªõi GitHub Actions. Ki·∫øn th·ª©c DevOps c·ªët l√µi CI/CD CI/CD (Continuous Integration/Continuous Deployment) l√† quy tr√¨nh t·ª± ƒë·ªông h√≥a vi·ªác t√≠ch h·ª£p v√† tri·ªÉn khai m√£ ngu·ªìn. N√≥ gi√∫p gi·∫£m thi·ªÉu l·ªói v√† tƒÉng t·ªëc ƒë·ªô ph√°t tri·ªÉn ph·∫ßn m·ªÅm.\nContinuous Integration: T√≠ch h·ª£p m√£ ngu·ªìn th∆∞·ªùng xuy√™n ƒë·ªÉ ph√°t hi·ªán l·ªói s·ªõm. Continuous Deployment: T·ª± ƒë·ªông tri·ªÉn khai m√£ ngu·ªìn sau khi ki·ªÉm th·ª≠ th√†nh c√¥ng. V√≠ d·ª•: M·ªói khi push l√™n nh√°nh main, GitHub Actions s·∫Ω t·ª± ƒë·ªông th·ª±c hi·ªán c√°c b∆∞·ªõc: build image, push l√™n ECR, v√† deploy l√™n ECS Fargate. Containerization Containerization l√† k·ªπ thu·∫≠t ƒë√≥ng g√≥i ·ª©ng d·ª•ng v√† c√°c ph·ª• thu·ªôc v√†o m·ªôt container. Docker l√† c√¥ng c·ª• ph·ªï bi·∫øn nh·∫•t ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu n√†y.\n∆Øu ƒëi·ªÉm: D·ªÖ d√†ng tri·ªÉn khai, nh·∫•t qu√°n gi·ªØa c√°c m√¥i tr∆∞·ªùng. C√¥ng c·ª•: Docker, Kubernetes. ECS Fargate ECS Fargate l√† d·ªãch v·ª• c·ªßa AWS gi√∫p ch·∫°y container m√† kh√¥ng c·∫ßn qu·∫£n l√Ω server.\n∆Øu ƒëi·ªÉm: Kh√¥ng c·∫ßn qu·∫£n l√Ω c∆° s·ªü h·∫° t·∫ßng. ·ª®ng d·ª•ng: Ch·∫°y c√°c ·ª©ng d·ª•ng containerized. C√¥ng ngh·ªá s·ª≠ d·ª•ng GitHub Actions: T·ª± ƒë·ªông h√≥a quy tr√¨nh CI/CD. Workshop n√†y s·ª≠ d·ª•ng GitHub Actions thay v√¨ AWS CodePipeline v√¨ d·ªÖ ti·∫øp c·∫≠n v·ªõi fresher. Docker: ƒê√≥ng g√≥i ·ª©ng d·ª•ng. Amazon ECR: L∆∞u tr·ªØ container image. Amazon ECS Fargate: Ch·∫°y container. CloudWatch: Theo d√µi log v√† tr·∫°ng th√°i h·ªá th·ªëng. Ki·∫øn tr√∫c t·ªïng qu√°t D∆∞·ªõi ƒë√¢y l√† s∆° ƒë·ªì ki·∫øn tr√∫c t·ªïng qu√°t c·ªßa h·ªá th·ªëng:\nFrontend: React app. Backend: Node.js ho·∫∑c Flask app. ECR: L∆∞u tr·ªØ container image. ECS Fargate: Ch·∫°y container. Application Load Balancer: Ph√¢n ph·ªëi traffic. CloudWatch: Ghi log v√† gi√°m s√°t. Tip: ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√≥ t√†i kho·∫£n AWS v√† hi·ªÉu c∆° b·∫£n v·ªÅ c√°c d·ªãch v·ª• AWS tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduction/",
	"title": "üß± Ch∆∞∆°ng 1: Gi·ªõi thi·ªáu t·ªïng quan",
	"tags": [],
	"description": "",
	"content": "M·ª•c ti√™u workshop Trong workshop n√†y, b·∫°n s·∫Ω h·ªçc c√°ch deploy m·ªôt ·ª©ng d·ª•ng g·ªìm nhi·ªÅu container (frontend + backend) l√™n AWS ECS Fargate. M·ª•c ti√™u ch√≠nh:\nHi·ªÉu quy tr√¨nh CI/CD c∆° b·∫£n. Docker h√≥a ·ª©ng d·ª•ng frontend v√† backend. S·ª≠ d·ª•ng c√°c d·ªãch v·ª• AWS nh∆∞ ECR, ECS Fargate, v√† CloudWatch. C√°c b∆∞·ªõc ch√≠nh T√¨m hi·ªÉu v·ªÅ CI/CD v√† containerization. Docker h√≥a ·ª©ng d·ª•ng frontend v√† backend. ƒê·∫©y container image l√™n Amazon ECR. Deploy container l√™n ECS Fargate. T·ª± ƒë·ªông h√≥a quy tr√¨nh v·ªõi GitHub Actions. Ki·∫øn th·ª©c DevOps c·ªët l√µi CI/CD CI/CD (Continuous Integration/Continuous Deployment) l√† quy tr√¨nh t·ª± ƒë·ªông h√≥a vi·ªác t√≠ch h·ª£p v√† tri·ªÉn khai m√£ ngu·ªìn. N√≥ gi√∫p gi·∫£m thi·ªÉu l·ªói v√† tƒÉng t·ªëc ƒë·ªô ph√°t tri·ªÉn ph·∫ßn m·ªÅm.\nContinuous Integration: T√≠ch h·ª£p m√£ ngu·ªìn th∆∞·ªùng xuy√™n ƒë·ªÉ ph√°t hi·ªán l·ªói s·ªõm. Continuous Deployment: T·ª± ƒë·ªông tri·ªÉn khai m√£ ngu·ªìn sau khi ki·ªÉm th·ª≠ th√†nh c√¥ng. V√≠ d·ª•: M·ªói khi push l√™n nh√°nh main, GitHub Actions s·∫Ω t·ª± ƒë·ªông th·ª±c hi·ªán c√°c b∆∞·ªõc: build image, push l√™n ECR, v√† deploy l√™n ECS Fargate. Containerization Containerization l√† k·ªπ thu·∫≠t ƒë√≥ng g√≥i ·ª©ng d·ª•ng v√† c√°c ph·ª• thu·ªôc v√†o m·ªôt container. Docker l√† c√¥ng c·ª• ph·ªï bi·∫øn nh·∫•t ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu n√†y.\n∆Øu ƒëi·ªÉm: D·ªÖ d√†ng tri·ªÉn khai, nh·∫•t qu√°n gi·ªØa c√°c m√¥i tr∆∞·ªùng. C√¥ng c·ª•: Docker, Kubernetes. ECS Fargate ECS Fargate l√† d·ªãch v·ª• c·ªßa AWS gi√∫p ch·∫°y container m√† kh√¥ng c·∫ßn qu·∫£n l√Ω server.\n∆Øu ƒëi·ªÉm: Kh√¥ng c·∫ßn qu·∫£n l√Ω c∆° s·ªü h·∫° t·∫ßng. ·ª®ng d·ª•ng: Ch·∫°y c√°c ·ª©ng d·ª•ng containerized. C√¥ng ngh·ªá s·ª≠ d·ª•ng GitHub Actions: T·ª± ƒë·ªông h√≥a quy tr√¨nh CI/CD. Workshop n√†y s·ª≠ d·ª•ng GitHub Actions thay v√¨ AWS CodePipeline v√¨ d·ªÖ ti·∫øp c·∫≠n v·ªõi fresher. Docker: ƒê√≥ng g√≥i ·ª©ng d·ª•ng. Amazon ECR: L∆∞u tr·ªØ container image. Amazon ECS Fargate: Ch·∫°y container. CloudWatch: Theo d√µi log v√† tr·∫°ng th√°i h·ªá th·ªëng. Ki·∫øn tr√∫c t·ªïng qu√°t D∆∞·ªõi ƒë√¢y l√† s∆° ƒë·ªì ki·∫øn tr√∫c t·ªïng qu√°t c·ªßa h·ªá th·ªëng:\nFrontend: React app. Backend: Node.js ho·∫∑c Flask app. ECR: L∆∞u tr·ªØ container image. ECS Fargate: Ch·∫°y container. Application Load Balancer: Ph√¢n ph·ªëi traffic. CloudWatch: Ghi log v√† gi√°m s√°t. Tip: ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√≥ t√†i kho·∫£n AWS v√† hi·ªÉu c∆° b·∫£n v·ªÅ c√°c d·ªãch v·ª• AWS tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.\n"
},
{
	"uri": "//localhost:1313/en/2-dockerize/",
	"title": "üîß Chapter 2: Project Preparation &amp; Application Dockerization",
	"tags": [],
	"description": "",
	"content": "Initial Assumptions You already have source code for frontend (React) and backend (Node.js or Flask) applications in the same repository. Clone repository from GitHub: # Clone repository containing both frontend and backend git clone https://github.com/leduy8103/ecs-cicd-workshop.git Check Dockerfile Dockerfile for Frontend (React) # Use Node.js image FROM node:16 # Set working directory WORKDIR /app # Copy package.json and install dependencies COPY package.json ./ RUN npm install # Copy entire source code COPY . . # Build application RUN npm run build # Use Nginx image to serve the application FROM nginx:alpine COPY --from=0 /app/build /usr/share/nginx/html # Expose port EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] Dockerfile for Backend (Node.js) # Use Node.js image FROM node:16 # Set working directory WORKDIR /app # Copy package.json and install dependencies COPY package.json ./ RUN npm install # Copy entire source code COPY . . # Expose port EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] Tip: Make sure the Dockerfile has been tested and works properly before proceeding.\n"
},
{
	"uri": "//localhost:1313/2-dockerize/",
	"title": "üîß Ch∆∞∆°ng 2: Chu·∫©n b·ªã d·ª± √°n &amp; Docker h√≥a ·ª©ng d·ª•ng",
	"tags": [],
	"description": "",
	"content": "Gi·∫£ ƒë·ªãnh ban ƒë·∫ßu B·∫°n ƒë√£ c√≥ s·∫µn m√£ ngu·ªìn cho ·ª©ng d·ª•ng frontend (React) v√† backend (Node.js ho·∫∑c Flask) trong c√πng m·ªôt repository. Clone repository t·ª´ GitHub: # Clone repository ch·ª©a c·∫£ frontend v√† backend git clone https://github.com/leduy8103/ecs-cicd-workshop.git Ki·ªÉm tra Dockerfile Dockerfile cho Frontend (React) # S·ª≠ d·ª•ng image Node.js FROM node:16 # Thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác WORKDIR /app # Copy package.json v√† c√†i ƒë·∫∑t dependencies COPY package.json ./ RUN npm install # Copy to√†n b·ªô m√£ ngu·ªìn COPY . . # Build ·ª©ng d·ª•ng RUN npm run build # S·ª≠ d·ª•ng image Nginx ƒë·ªÉ ph·ª•c v·ª• ·ª©ng d·ª•ng FROM nginx:alpine COPY --from=0 /app/build /usr/share/nginx/html # Expose port EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] Dockerfile cho Backend (Node.js) # S·ª≠ d·ª•ng image Node.js FROM node:16 # Thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác WORKDIR /app # Copy package.json v√† c√†i ƒë·∫∑t dependencies COPY package.json ./ RUN npm install # Copy to√†n b·ªô m√£ ngu·ªìn COPY . . # Expose port EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] Tip: ƒê·∫£m b·∫£o Dockerfile ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra v√† ho·∫°t ƒë·ªông ƒë√∫ng tr∆∞·ªõc khi ti·∫øp t·ª•c.\n"
},
{
	"uri": "//localhost:1313/vi/2-dockerize/",
	"title": "üîß Ch∆∞∆°ng 2: Chu·∫©n b·ªã d·ª± √°n &amp; Docker h√≥a ·ª©ng d·ª•ng",
	"tags": [],
	"description": "",
	"content": "Gi·∫£ ƒë·ªãnh ban ƒë·∫ßu B·∫°n ƒë√£ c√≥ s·∫µn m√£ ngu·ªìn cho ·ª©ng d·ª•ng frontend (React) v√† backend (Node.js ho·∫∑c Flask) trong c√πng m·ªôt repository. Clone repository t·ª´ GitHub: # Clone repository ch·ª©a c·∫£ frontend v√† backend git clone https://github.com/leduy8103/ecs-cicd-workshop.git Ki·ªÉm tra Dockerfile Dockerfile cho Frontend (React) # S·ª≠ d·ª•ng image Node.js FROM node:16 # Thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác WORKDIR /app # Copy package.json v√† c√†i ƒë·∫∑t dependencies COPY package.json ./ RUN npm install # Copy to√†n b·ªô m√£ ngu·ªìn COPY . . # Build ·ª©ng d·ª•ng RUN npm run build # S·ª≠ d·ª•ng image Nginx ƒë·ªÉ ph·ª•c v·ª• ·ª©ng d·ª•ng FROM nginx:alpine COPY --from=0 /app/build /usr/share/nginx/html # Expose port EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] Dockerfile cho Backend (Node.js) # S·ª≠ d·ª•ng image Node.js FROM node:16 # Thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác WORKDIR /app # Copy package.json v√† c√†i ƒë·∫∑t dependencies COPY package.json ./ RUN npm install # Copy to√†n b·ªô m√£ ngu·ªìn COPY . . # Expose port EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] Tip: ƒê·∫£m b·∫£o Dockerfile ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra v√† ho·∫°t ƒë·ªông ƒë√∫ng tr∆∞·ªõc khi ti·∫øp t·ª•c.\n"
},
{
	"uri": "//localhost:1313/en/3-ecr/",
	"title": "üì¶ Chapter 3: Create ECR repositories and push images",
	"tags": [],
	"description": "",
	"content": "Create repository in Amazon ECR Steps to follow Access AWS Management Console. Navigate to ECR (Elastic Container Registry). Create 2 repositories: frontend-app backend-app Tip: Name repositories clearly for easy management.\nBuild and push images to ECR Using GitHub Actions Create file .github/workflows/deploy.yml name: Build and Push to ECR on: push: branches: - main jobs: build-and-push: runs-on: ubuntu-latest env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Checkout code uses: actions/checkout@v3 - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v1 with: aws-region: ${{ env.AWS_REGION }} - name: Build frontend image run: | docker build -t frontend-app ./frontend-app docker tag frontend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Push frontend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Build backend image run: | docker build -t backend-app ./backend-app docker tag backend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Push backend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActionsRole aws-region: ${{ env.AWS_REGION }} Set up secrets on GitHub To use secrets in GitHub Actions, you need to set up secrets in your repository.\nSteps to follow Access your repository on GitHub. Navigate to Settings \u0026gt; Secrets and variables \u0026gt; Actions. Click New repository secret to add new secrets.\nAdd the necessary secrets:\nAWS_REGION: Your AWS region (e.g., ap-southeast-1). AWS_ACCOUNT_ID: Your AWS account ID. AWS_ACCESS_KEY_ID: Access key ID of IAM user or role. AWS_SECRET_ACCESS_KEY: Secret access key of IAM user or role. Warning: Make sure these secrets are secure and not shared publicly.\nUsing secrets in workflow In the workflow file .github/workflows/deploy.yml, you can access secrets using the syntax secrets.\u0026lt;SECRET_NAME\u0026gt;.\nExample:\nenv: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} Using AWS CLI Login to ECR aws ecr get-login-password --region \u0026lt;AWS_REGION\u0026gt; | docker login --username AWS --password-stdin \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com Build and push images # Frontend docker build -t frontend-app ./frontend-app docker tag frontend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest # Backend docker build -t backend-app ./backend-app docker tag backend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Check results Access AWS Management Console to verify images have been pushed to repositories. Ensure images have latest tag and correct format. "
},
{
	"uri": "//localhost:1313/3-ecr/",
	"title": "üì¶ Ch∆∞∆°ng 3: T·∫°o ECR repositories v√† ƒë·∫©y image",
	"tags": [],
	"description": "",
	"content": "T·∫°o repository trong Amazon ECR C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn ECR (Elastic Container Registry). T·∫°o 2 repository: frontend-app backend-app Tip: ƒê·∫∑t t√™n repository r√µ r√†ng ƒë·ªÉ d·ªÖ qu·∫£n l√Ω.\nBuild v√† push image l√™n ECR S·ª≠ d·ª•ng GitHub Actions T·∫°o file .github/workflows/deploy.yml name: Build and Push to ECR on: push: branches: - main jobs: build-and-push: runs-on: ubuntu-latest env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Checkout code uses: actions/checkout@v3 - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v1 with: aws-region: ${{ env.AWS_REGION }} - name: Build frontend image run: | docker build -t frontend-app ./frontend-app docker tag frontend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Push frontend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Build backend image run: | docker build -t backend-app ./backend-app docker tag backend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Push backend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActionsRole aws-region: ${{ env.AWS_REGION }} Thi·∫øt l·∫≠p secrets tr√™n GitHub ƒê·ªÉ s·ª≠ d·ª•ng secrets trong GitHub Actions, b·∫°n c·∫ßn thi·∫øt l·∫≠p c√°c secrets trong repository c·ªßa m√¨nh.\nC√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p repository c·ªßa b·∫°n tr√™n GitHub. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn Settings \u0026gt; Secrets and variables \u0026gt; Actions. Nh·∫•n New repository secret ƒë·ªÉ th√™m secrets m·ªõi.\nTh√™m c√°c secrets c·∫ßn thi·∫øt:\nAWS_REGION: V√πng AWS c·ªßa b·∫°n (v√≠ d·ª•: ap-southeast-1). AWS_ACCOUNT_ID: ID t√†i kho·∫£n AWS c·ªßa b·∫°n. AWS_ACCESS_KEY_ID: Access key ID c·ªßa IAM user ho·∫∑c role. AWS_SECRET_ACCESS_KEY: Secret access key c·ªßa IAM user ho·∫∑c role. C·∫£nh b√°o: ƒê·∫£m b·∫£o r·∫±ng c√°c secrets n√†y ƒë∆∞·ª£c b·∫£o m·∫≠t v√† kh√¥ng chia s·∫ª c√¥ng khai.\nS·ª≠ d·ª•ng secrets trong workflow Trong file workflow .github/workflows/deploy.yml, b·∫°n c√≥ th·ªÉ truy c·∫≠p c√°c secrets b·∫±ng c√∫ ph√°p secrets.\u0026lt;SECRET_NAME\u0026gt;.\nV√≠ d·ª•:\nenv: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} S·ª≠ d·ª•ng AWS CLI ƒêƒÉng nh·∫≠p v√†o ECR aws ecr get-login-password --region \u0026lt;AWS_REGION\u0026gt; | docker login --username AWS --password-stdin \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com Build v√† push image # Frontend docker build -t frontend-app ./frontend-app docker tag frontend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest # Backend docker build -t backend-app ./backend-app docker tag backend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Ki·ªÉm tra k·∫øt qu·∫£ Truy c·∫≠p AWS Management Console ƒë·ªÉ ki·ªÉm tra c√°c image ƒë√£ ƒë∆∞·ª£c ƒë·∫©y l√™n repository. ƒê·∫£m b·∫£o c√°c image c√≥ tag latest v√† ƒë√∫ng ƒë·ªãnh d·∫°ng. "
},
{
	"uri": "//localhost:1313/vi/3-ecr/",
	"title": "üì¶ Ch∆∞∆°ng 3: T·∫°o ECR repositories v√† ƒë·∫©y image",
	"tags": [],
	"description": "",
	"content": "T·∫°o repository trong Amazon ECR C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn ECR (Elastic Container Registry). T·∫°o 2 repository: frontend-app backend-app Tip: ƒê·∫∑t t√™n repository r√µ r√†ng ƒë·ªÉ d·ªÖ qu·∫£n l√Ω.\nBuild v√† push image l√™n ECR S·ª≠ d·ª•ng GitHub Actions T·∫°o file .github/workflows/deploy.yml name: Build and Push to ECR on: push: branches: - main jobs: build-and-push: runs-on: ubuntu-latest env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Checkout code uses: actions/checkout@v3 - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v1 with: aws-region: ${{ env.AWS_REGION }} - name: Build frontend image run: | docker build -t frontend-app ./frontend-app docker tag frontend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Push frontend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/frontend-app:latest - name: Build backend image run: | docker build -t backend-app ./backend-app docker tag backend-app:latest ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Push backend image run: | docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/backend-app:latest - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActionsRole aws-region: ${{ env.AWS_REGION }} Thi·∫øt l·∫≠p secrets tr√™n GitHub ƒê·ªÉ s·ª≠ d·ª•ng secrets trong GitHub Actions, b·∫°n c·∫ßn thi·∫øt l·∫≠p c√°c secrets trong repository c·ªßa m√¨nh.\nC√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p repository c·ªßa b·∫°n tr√™n GitHub. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn Settings \u0026gt; Secrets and variables \u0026gt; Actions. Nh·∫•n New repository secret ƒë·ªÉ th√™m secrets m·ªõi.\nTh√™m c√°c secrets c·∫ßn thi·∫øt:\nAWS_REGION: V√πng AWS c·ªßa b·∫°n (v√≠ d·ª•: ap-southeast-1). AWS_ACCOUNT_ID: ID t√†i kho·∫£n AWS c·ªßa b·∫°n. AWS_ACCESS_KEY_ID: Access key ID c·ªßa IAM user ho·∫∑c role. AWS_SECRET_ACCESS_KEY: Secret access key c·ªßa IAM user ho·∫∑c role. C·∫£nh b√°o: ƒê·∫£m b·∫£o r·∫±ng c√°c secrets n√†y ƒë∆∞·ª£c b·∫£o m·∫≠t v√† kh√¥ng chia s·∫ª c√¥ng khai.\nS·ª≠ d·ª•ng secrets trong workflow Trong file workflow .github/workflows/deploy.yml, b·∫°n c√≥ th·ªÉ truy c·∫≠p c√°c secrets b·∫±ng c√∫ ph√°p secrets.\u0026lt;SECRET_NAME\u0026gt;.\nV√≠ d·ª•:\nenv: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} steps: - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} S·ª≠ d·ª•ng AWS CLI ƒêƒÉng nh·∫≠p v√†o ECR aws ecr get-login-password --region \u0026lt;AWS_REGION\u0026gt; | docker login --username AWS --password-stdin \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com Build v√† push image # Frontend docker build -t frontend-app ./frontend-app docker tag frontend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest # Backend docker build -t backend-app ./backend-app docker tag backend-app:latest \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest docker push \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Ki·ªÉm tra k·∫øt qu·∫£ Truy c·∫≠p AWS Management Console ƒë·ªÉ ki·ªÉm tra c√°c image ƒë√£ ƒë∆∞·ª£c ƒë·∫©y l√™n repository. ƒê·∫£m b·∫£o c√°c image c√≥ tag latest v√† ƒë√∫ng ƒë·ªãnh d·∫°ng. "
},
{
	"uri": "//localhost:1313/en/4-deploy-ecs-fargate/",
	"title": "üöÄ Chapter 4: Deploy ECS Fargate",
	"tags": [],
	"description": "",
	"content": "üéØ Chapter Objectives In this chapter, you will learn how to deploy dockerized frontend and backend applications pushed to ECR using Amazon ECS Fargate ‚Äì a serverless container service on AWS.\nüì¶ Step 1: Create ECS Cluster Access AWS Console ‚Üí find ECS Select Clusters ‚Üí click Create Cluster Choose cluster type: Networking only (Fargate) Name: workshop-cluster-81 Click Create ‚úÖ The cluster will have no EC2 instances because you\u0026rsquo;re using Fargate (serverless).\nüß± Step 2: Create Task Definition You need to create 2 task definitions ‚Äì one for frontend and one for backend.\n‚ú® 2.1. Frontend Task ECS ‚Üí Task Definitions ‚Üí Create new Task Definition Launch type: Fargate Task name: frontend-task CPU: 0.5 vCPU, Memory: 1 GB Click Add container:\nContainer name: frontend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest Port mappings: 80 Click Create\n‚ú® 2.2. Backend Task Repeat the above steps with:\nTask name: backend-task Container name: backend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Port mappings: 3000 ‚úÖ Successfully created backend-task and frontend-task. üåê Step 3: Create VPC and Networking If you don\u0026rsquo;t have a suitable VPC, create one following these steps:\nAccess VPC ‚Üí Create VPC Name: workshop-vpc, CIDR block: 10.0.0.0/16 Create 2 subnets: Subnet 1: 10.0.1.0/24 ‚Äì Public Subnet 2: 10.0.2.0/24 ‚Äì Private Create Internet Gateway ‚Üí attach to workshop-vpc Update Route Table: Public Route Table: route 0.0.0.0/0 to Internet Gateway Assign this route table to Subnet 1 ‚ö†Ô∏è Only frontend needs internet access (public subnet). Backend can be placed in private subnet.\nüîê Step 4: Create Security Group Go to EC2 ‚Üí Security Groups ‚Üí Create Security Group Name: frontend-sg, description: Allow HTTP Inbound rules: Type: HTTP Port: 80 Source: 0.0.0.0/0 Outbound: keep default (Allow all) Create additional backend-sg:\nInbound: Type: Custom TCP, Port 3000 Source: frontend-sg (select from group list) Outbound: default üõ† Step 5: Create ECS Service (run containers) 5.1. Create Frontend Service Go to ECS ‚Üí workshop-cluster Select Services tab ‚Üí Create Fill information: Launch type: Fargate Task definition: frontend-task Service name: frontend-service Number of tasks: 1 Cluster VPC: select workshop-vpc Subnet: select public subnet Security Group: select frontend-sg Check Enable public IP Click Create Service 5.2. Create Backend Service Repeat the above steps with:\nTask: backend-task Subnet: select private subnet (or public if needed for simple demo) SG: backend-sg No public IP needed if not calling directly from browser üîç Check deployment After creation:\nECS will run 2 tasks in 2 services. Go to ECS \u0026gt; Clusters \u0026gt; Tasks to check RUNNING status If not visible, check Security Group and ECR image push again.\n"
},
{
	"uri": "//localhost:1313/4-deploy-ecs-fargate/",
	"title": "üöÄ Ch∆∞∆°ng 4: Deploy ECS Fargate",
	"tags": [],
	"description": "",
	"content": "üéØ M·ª•c ti√™u ch∆∞∆°ng Trong ch∆∞∆°ng n√†y, b·∫°n s·∫Ω h·ªçc c√°ch tri·ªÉn khai ·ª©ng d·ª•ng frontend v√† backend ƒë√£ ƒë∆∞·ª£c Docker h√≥a v√† ƒë·∫©y l√™n ECR, b·∫±ng c√°ch s·ª≠ d·ª•ng Amazon ECS Fargate ‚Äì m·ªôt d·ªãch v·ª• serverless cho container tr√™n AWS.\nüì¶ B∆∞·ªõc 1: T·∫°o ECS Cluster Truy c·∫≠p AWS Console ‚Üí t√¨m ECS Ch·ªçn Clusters ‚Üí nh·∫•n Create Cluster Ch·ªçn lo·∫°i cluster: Networking only (Fargate) ƒê·∫∑t t√™n: workshop-cluster-81 Nh·∫•n Create ‚úÖ Cluster s·∫Ω kh√¥ng c√≥ EC2 instance v√¨ b·∫°n ƒëang d√πng Fargate (serverless).\nüß± B∆∞·ªõc 2: T·∫°o Task Definition B·∫°n c·∫ßn t·∫°o 2 task definitions ‚Äì m·ªôt cho frontend v√† m·ªôt cho backend.\n‚ú® 2.1. Frontend Task ECS ‚Üí Task Definitions ‚Üí Create new Task Definition Launch type: Fargate Task name: frontend-task CPU: 0.5 vCPU, Memory: 1 GB Nh·∫•n Add container:\nContainer name: frontend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest Port mappings: 80 Nh·∫•n Create\n‚ú® 2.2. Backend Task L·∫∑p l·∫°i c√°c b∆∞·ªõc tr√™n v·ªõi:\nTask name: backend-task Container name: backend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Port mappings: 3000 ‚úÖ T·∫°o th√†nh c√¥ng backend-task v√† frontend-task. üåê B∆∞·ªõc 3: T·∫°o VPC v√† Networking N·∫øu b·∫°n ch∆∞a c√≥ VPC ph√π h·ª£p, h√£y t·∫°o VPC theo c√°c b∆∞·ªõc sau:\nTruy c·∫≠p VPC ‚Üí Create VPC T√™n: workshop-vpc, CIDR block: 10.0.0.0/16 T·∫°o 2 subnet: Subnet 1: 10.0.1.0/24 ‚Äì Public Subnet 2: 10.0.2.0/24 ‚Äì Private T·∫°o Internet Gateway ‚Üí g·∫Øn v√†o workshop-vpc C·∫≠p nh·∫≠t Route Table: Public Route Table: tr·ªè 0.0.0.0/0 ƒë·∫øn Internet Gateway G√°n route table n√†y cho Subnet 1 ‚ö†Ô∏è Ch·ªâ frontend c·∫ßn truy c·∫≠p internet (public subnet). Backend c√≥ th·ªÉ ƒë·∫∑t trong private subnet.\nüîê B∆∞·ªõc 4: T·∫°o Security Group V√†o EC2 ‚Üí Security Groups ‚Üí Create Security Group T√™n: frontend-sg, m√¥ t·∫£: Allow HTTP Inbound rules: Type: HTTP Port: 80 Source: 0.0.0.0/0 Outbound: gi·ªØ m·∫∑c ƒë·ªãnh (Allow all) T·∫°o th√™m backend-sg:\nInbound: Type: Custom TCP, Port 3000 Source: frontend-sg (ch·ªçn t·ª´ group list) Outbound: m·∫∑c ƒë·ªãnh üõ† B∆∞·ªõc 5: T·∫°o ECS Service (ch·∫°y container) 5.1. T·∫°o Frontend Service V√†o ECS ‚Üí workshop-cluster Ch·ªçn tab Services ‚Üí Create ƒêi·ªÅn th√¥ng tin: Launch type: Fargate Task definition: frontend-task Service name: frontend-service S·ªë l∆∞·ª£ng task: 1 Cluster VPC: ch·ªçn workshop-vpc Subnet: ch·ªçn subnet public Security Group: ch·ªçn frontend-sg T√≠ch Enable public IP Nh·∫•n Create Service 5.2. T·∫°o Backend Service L·∫∑p l·∫°i c√°c b∆∞·ªõc tr√™n, v·ªõi:\nTask: backend-task Subnet: ch·ªçn subnet private (ho·∫∑c public n·∫øu c·∫ßn demo ƒë∆°n gi·∫£n) SG: backend-sg Kh√¥ng c·∫ßn public IP n·∫øu kh√¥ng g·ªçi tr·ª±c ti·∫øp t·ª´ tr√¨nh duy·ªát üîç Ki·ªÉm tra tri·ªÉn khai Sau khi t·∫°o xong:\nECS s·∫Ω ch·∫°y 2 task trong 2 service. V√†o ECS \u0026gt; Clusters \u0026gt; Tasks ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i RUNNING N·∫øu kh√¥ng th·∫•y, ki·ªÉm tra l·∫°i Security Group v√† ECR image ƒë√£ push ƒë√∫ng ch∆∞a.\n"
},
{
	"uri": "//localhost:1313/vi/4-deploy-ecs-fargate/",
	"title": "üöÄ Ch∆∞∆°ng 4: Deploy ECS Fargate",
	"tags": [],
	"description": "",
	"content": "üéØ M·ª•c ti√™u ch∆∞∆°ng Trong ch∆∞∆°ng n√†y, b·∫°n s·∫Ω h·ªçc c√°ch tri·ªÉn khai ·ª©ng d·ª•ng frontend v√† backend ƒë√£ ƒë∆∞·ª£c Docker h√≥a v√† ƒë·∫©y l√™n ECR, b·∫±ng c√°ch s·ª≠ d·ª•ng Amazon ECS Fargate ‚Äì m·ªôt d·ªãch v·ª• serverless cho container tr√™n AWS.\nüì¶ B∆∞·ªõc 1: T·∫°o ECS Cluster Truy c·∫≠p AWS Console ‚Üí t√¨m ECS Ch·ªçn Clusters ‚Üí nh·∫•n Create Cluster Ch·ªçn lo·∫°i cluster: Networking only (Fargate) ƒê·∫∑t t√™n: workshop-cluster-81 Nh·∫•n Create ‚úÖ Cluster s·∫Ω kh√¥ng c√≥ EC2 instance v√¨ b·∫°n ƒëang d√πng Fargate (serverless).\nüß± B∆∞·ªõc 2: T·∫°o Task Definition B·∫°n c·∫ßn t·∫°o 2 task definitions ‚Äì m·ªôt cho frontend v√† m·ªôt cho backend.\n‚ú® 2.1. Frontend Task ECS ‚Üí Task Definitions ‚Üí Create new Task Definition Launch type: Fargate Task name: frontend-task CPU: 0.5 vCPU, Memory: 1 GB Nh·∫•n Add container:\nContainer name: frontend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/frontend-app:latest Port mappings: 80 Nh·∫•n Create\n‚ú® 2.2. Backend Task L·∫∑p l·∫°i c√°c b∆∞·ªõc tr√™n v·ªõi:\nTask name: backend-task Container name: backend Image URI: \u0026lt;AWS_ACCOUNT_ID\u0026gt;.dkr.ecr.\u0026lt;AWS_REGION\u0026gt;.amazonaws.com/backend-app:latest Port mappings: 3000 ‚úÖ T·∫°o th√†nh c√¥ng backend-task v√† frontend-task. üåê B∆∞·ªõc 3: T·∫°o VPC v√† Networking N·∫øu b·∫°n ch∆∞a c√≥ VPC ph√π h·ª£p, h√£y t·∫°o VPC theo c√°c b∆∞·ªõc sau:\nTruy c·∫≠p VPC ‚Üí Create VPC T√™n: workshop-vpc, CIDR block: 10.0.0.0/16 T·∫°o 2 subnet: Subnet 1: 10.0.1.0/24 ‚Äì Public Subnet 2: 10.0.2.0/24 ‚Äì Private T·∫°o Internet Gateway ‚Üí g·∫Øn v√†o workshop-vpc C·∫≠p nh·∫≠t Route Table: Public Route Table: tr·ªè 0.0.0.0/0 ƒë·∫øn Internet Gateway G√°n route table n√†y cho Subnet 1 ‚ö†Ô∏è Ch·ªâ frontend c·∫ßn truy c·∫≠p internet (public subnet). Backend c√≥ th·ªÉ ƒë·∫∑t trong private subnet.\nüîê B∆∞·ªõc 4: T·∫°o Security Group V√†o EC2 ‚Üí Security Groups ‚Üí Create Security Group T√™n: frontend-sg, m√¥ t·∫£: Allow HTTP Inbound rules: Type: HTTP Port: 80 Source: 0.0.0.0/0 Outbound: gi·ªØ m·∫∑c ƒë·ªãnh (Allow all) T·∫°o th√™m backend-sg:\nInbound: Type: Custom TCP, Port 3000 Source: frontend-sg (ch·ªçn t·ª´ group list) Outbound: m·∫∑c ƒë·ªãnh üõ† B∆∞·ªõc 5: T·∫°o ECS Service (ch·∫°y container) 5.1. T·∫°o Frontend Service V√†o ECS ‚Üí workshop-cluster Ch·ªçn tab Services ‚Üí Create ƒêi·ªÅn th√¥ng tin: Launch type: Fargate Task definition: frontend-task Service name: frontend-service S·ªë l∆∞·ª£ng task: 1 Cluster VPC: ch·ªçn workshop-vpc Subnet: ch·ªçn subnet public Security Group: ch·ªçn frontend-sg T√≠ch Enable public IP Nh·∫•n Create Service 5.2. T·∫°o Backend Service L·∫∑p l·∫°i c√°c b∆∞·ªõc tr√™n, v·ªõi:\nTask: backend-task Subnet: ch·ªçn subnet private (ho·∫∑c public n·∫øu c·∫ßn demo ƒë∆°n gi·∫£n) SG: backend-sg Kh√¥ng c·∫ßn public IP n·∫øu kh√¥ng g·ªçi tr·ª±c ti·∫øp t·ª´ tr√¨nh duy·ªát üîç Ki·ªÉm tra tri·ªÉn khai Sau khi t·∫°o xong:\nECS s·∫Ω ch·∫°y 2 task trong 2 service. V√†o ECS \u0026gt; Clusters \u0026gt; Tasks ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i RUNNING N·∫øu kh√¥ng th·∫•y, ki·ªÉm tra l·∫°i Security Group v√† ECR image ƒë√£ push ƒë√∫ng ch∆∞a.\n"
},
{
	"uri": "//localhost:1313/vi/4-rds-setup/",
	"title": "üóÑÔ∏è Ch∆∞∆°ng 4: Thi·∫øt l·∫≠p Amazon RDS",
	"tags": [],
	"description": "",
	"content": "Thi·∫øt l·∫≠p Amazon RDS Trong ch∆∞∆°ng n√†y, ch√∫ng ta s·∫Ω thi·∫øt l·∫≠p Amazon RDS l√†m database hi·ªán ƒë·∫°i ƒë·ªÉ thay th·∫ø cho h·ªá th·ªëng legacy MySQL. RDS s·∫Ω cung c·∫•p c√°c t√≠nh nƒÉng nh∆∞ backup t·ª± ƒë·ªông, patching, monitoring v√† high availability.\nM·ª•c ti√™u T·∫°o RDS MySQL instance C·∫•u h√¨nh security groups v√† networking Thi·∫øt l·∫≠p backup v√† maintenance T·∫°o database schema t∆∞∆°ng t·ª± legacy Test connection t·ª´ API wrapper B∆∞·ªõc 1: T·∫°o RDS Instance 1.1. T·∫°o RDS t·ª´ AWS Console ƒêƒÉng nh·∫≠p v√†o AWS Console Ch·ªçn service RDS Click Create database C·∫•u h√¨nh nh∆∞ sau: Engine Options:\nEngine Type: MySQL Version: MySQL 8.0.35 (latest) Template: Free tier (cho workshop) Settings:\nDB Instance Identifier: modernized-mysql-db Master username: admin Master password: SecureRdsPassword123! DB Instance Class:\nInstance Class: db.t3.micro (free tier) Storage:\nStorage Type: General Purpose SSD (gp2) Allocated Storage: 20 GB Enable Storage Autoscaling: Yes Maximum Storage Threshold: 100 GB Connectivity:\nVPC: Default VPC Subnet group: Default Public access: No (recommended for production) VPC security group: Create new Availability Zone: No preference Database authentication:\nDatabase authentication: Password authentication Additional configuration:\nInitial database name: modernized_db Backup retention: 7 days Backup window: Default Maintenance window: Default Enable Enhanced monitoring: Yes (60 seconds) 1.2. T·∫°o b·∫±ng AWS CLI (Alternative) # Create DB subnet group aws rds create-db-subnet-group \\ --db-subnet-group-name modernized-subnet-group \\ --db-subnet-group-description \u0026#34;Subnet group for modernized database\u0026#34; \\ --subnet-ids subnet-12345678 subnet-87654321 # Create security group aws ec2 create-security-group \\ --group-name rds-security-group \\ --description \u0026#34;Security group for RDS\u0026#34; # Get security group ID SG_ID=$(aws ec2 describe-security-groups \\ --group-names rds-security-group \\ --query \u0026#39;SecurityGroups[0].GroupId\u0026#39; \\ --output text) # Add inbound rule for MySQL aws ec2 authorize-security-group-ingress \\ --group-id $SG_ID \\ --protocol tcp \\ --port 3306 \\ --cidr 10.0.0.0/8 # Create RDS instance aws rds create-db-instance \\ --db-instance-identifier modernized-mysql-db \\ --db-instance-class db.t3.micro \\ --engine mysql \\ --master-username admin \\ --master-user-password SecureRdsPassword123! \\ --allocated-storage 20 \\ --vpc-security-group-ids $SG_ID \\ --db-name modernized_db \\ --backup-retention-period 7 \\ --storage-encrypted \\ --monitoring-interval 60 \\ --monitoring-role-arn arn:aws:iam::YOUR_ACCOUNT:role/rds-monitoring-role B∆∞·ªõc 2: C·∫•u h√¨nh Security Groups 2.1. T·∫°o Security Group cho RDS # Create security group aws ec2 create-security-group \\ --group-name rds-modernized-sg \\ --description \u0026#34;Security group for modernized RDS instance\u0026#34; # Get security group ID RDS_SG_ID=$(aws ec2 describe-security-groups \\ --group-names rds-modernized-sg \\ --query \u0026#39;SecurityGroups[0].GroupId\u0026#39; \\ --output text) # Allow MySQL access from API wrapper instances aws ec2 authorize-security-group-ingress \\ --group-id $RDS_SG_ID \\ --protocol tcp \\ --port 3306 \\ --source-group \u0026lt;api-wrapper-security-group-id\u0026gt; # Allow MySQL access from your IP for management aws ec2 authorize-security-group-ingress \\ --group-id $RDS_SG_ID \\ --protocol tcp \\ --port 3306 \\ --cidr \u0026lt;your-ip\u0026gt;/32 B∆∞·ªõc 3: Thi·∫øt l·∫≠p Database Schema 3.1. K·∫øt n·ªëi v·ªõi RDS instance # Get RDS endpoint RDS_ENDPOINT=$(aws rds describe-db-instances \\ --db-instance-identifier modernized-mysql-db \\ --query \u0026#39;DBInstances[0].Endpoint.Address\u0026#39; \\ --output text) # Connect to RDS mysql -h $RDS_ENDPOINT -u admin -p 3.2. T·∫°o database schema -- Create database CREATE DATABASE modernized_db; USE modernized_db; -- Create customers table CREATE TABLE customers ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, email VARCHAR(100) UNIQUE NOT NULL, phone VARCHAR(20), address TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- Add indexes for performance INDEX idx_email (email), INDEX idx_name (name), INDEX idx_created_at (created_at) ); -- Create products table CREATE TABLE products ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, description TEXT, price DECIMAL(10,2) NOT NULL, stock_quantity INT DEFAULT 0, category VARCHAR(50), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- Add indexes for performance INDEX idx_category (category), INDEX idx_price (price), INDEX idx_name (name), INDEX idx_created_at (created_at) ); -- Create orders table CREATE TABLE orders ( id INT AUTO_INCREMENT PRIMARY KEY, customer_id INT NOT NULL, total_amount DECIMAL(10,2) NOT NULL, status ENUM(\u0026#39;pending\u0026#39;, \u0026#39;processing\u0026#39;, \u0026#39;shipped\u0026#39;, \u0026#39;delivered\u0026#39;, \u0026#39;cancelled\u0026#39;) DEFAULT \u0026#39;pending\u0026#39;, order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Add foreign key constraint FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE, -- Add indexes for performance INDEX idx_customer_id (customer_id), INDEX idx_status (status), INDEX idx_order_date (order_date) ); -- Create order_items table CREATE TABLE order_items ( id INT AUTO_INCREMENT PRIMARY KEY, order_id INT NOT NULL, product_id INT NOT NULL, quantity INT NOT NULL, unit_price DECIMAL(10,2) NOT NULL, -- Add foreign key constraints FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE, FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE, -- Add indexes for performance INDEX idx_order_id (order_id), INDEX idx_product_id (product_id) ); -- Create audit table for tracking changes CREATE TABLE audit_log ( id INT AUTO_INCREMENT PRIMARY KEY, table_name VARCHAR(50) NOT NULL, operation VARCHAR(10) NOT NULL, record_id INT NOT NULL, old_values JSON, new_values JSON, changed_by VARCHAR(100), changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, INDEX idx_table_name (table_name), INDEX idx_changed_at (changed_at) ); 3.3. T·∫°o database user cho application -- Create application user CREATE USER \u0026#39;app_user\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;SecureAppPassword123!\u0026#39;; -- Grant permissions GRANT SELECT, INSERT, UPDATE, DELETE ON modernized_db.* TO \u0026#39;app_user\u0026#39;@\u0026#39;%\u0026#39;; FLUSH PRIVILEGES; -- Create read-only user for reporting CREATE USER \u0026#39;report_user\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;SecureReportPassword123!\u0026#39;; GRANT SELECT ON modernized_db.* TO \u0026#39;report_user\u0026#39;@\u0026#39;%\u0026#39;; FLUSH PRIVILEGES; B∆∞·ªõc 4: C·∫•u h√¨nh Backup v√† Maintenance 4.1. C·∫•u h√¨nh automated backup # Modify DB instance to enable automated backups aws rds modify-db-instance \\ --db-instance-identifier modernized-mysql-db \\ --backup-retention-period 7 \\ --preferred-backup-window \u0026#34;03:00-04:00\u0026#34; \\ --preferred-maintenance-window \u0026#34;sun:04:00-sun:05:00\u0026#34; \\ --apply-immediately 4.2. T·∫°o manual snapshot # Create manual snapshot aws rds create-db-snapshot \\ --db-instance-identifier modernized-mysql-db \\ --db-snapshot-identifier modernized-mysql-snapshot-$(date +%Y%m%d) B∆∞·ªõc 5: C·∫•u h√¨nh Parameter Groups 5.1. T·∫°o custom parameter group # Create parameter group aws rds create-db-parameter-group \\ --db-parameter-group-name modernized-mysql-params \\ --db-parameter-group-family mysql8.0 \\ --description \u0026#34;Custom parameter group for modernized MySQL\u0026#34; # Set parameters for better performance aws rds modify-db-parameter-group \\ --db-parameter-group-name modernized-mysql-params \\ --parameters \u0026#34;ParameterName=innodb_buffer_pool_size,ParameterValue={DBInstanceClassMemory*3/4},ApplyMethod=pending-reboot\u0026#34; aws rds modify-db-parameter-group \\ --db-parameter-group-name modernized-mysql-params \\ --parameters \u0026#34;ParameterName=slow_query_log,ParameterValue=1,ApplyMethod=immediate\u0026#34; aws rds modify-db-parameter-group \\ --db-parameter-group-name modernized-mysql-params \\ --parameters \u0026#34;ParameterName=long_query_time,ParameterValue=2,ApplyMethod=immediate\u0026#34; # Apply parameter group to instance aws rds modify-db-instance \\ --db-instance-identifier modernized-mysql-db \\ --db-parameter-group-name modernized-mysql-params B∆∞·ªõc 6: Monitoring v√† Alerts 6.1. Thi·∫øt l·∫≠p CloudWatch alarms # CPU utilization alarm aws cloudwatch put-metric-alarm \\ --alarm-name \u0026#34;RDS-CPU-Utilization-High\u0026#34; \\ --alarm-description \u0026#34;RDS CPU utilization is too high\u0026#34; \\ --metric-name CPUUtilization \\ --namespace AWS/RDS \\ --statistic Average \\ --period 300 \\ --threshold 80 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 2 \\ --dimensions Name=DBInstanceIdentifier,Value=modernized-mysql-db # Database connections alarm aws cloudwatch put-metric-alarm \\ --alarm-name \u0026#34;RDS-Database-Connections-High\u0026#34; \\ --alarm-description \u0026#34;RDS database connections are too high\u0026#34; \\ --metric-name DatabaseConnections \\ --namespace AWS/RDS \\ --statistic Average \\ --period 300 \\ --threshold 80 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 2 \\ --dimensions Name=DBInstanceIdentifier,Value=modernized-mysql-db # Free storage space alarm aws cloudwatch put-metric-alarm \\ --alarm-name \u0026#34;RDS-Free-Storage-Space-Low\u0026#34; \\ --alarm-description \u0026#34;RDS free storage space is too low\u0026#34; \\ --metric-name FreeStorageSpace \\ --namespace AWS/RDS \\ --statistic Average \\ --period 300 \\ --threshold 2000000000 \\ --comparison-operator LessThanThreshold \\ --evaluation-periods 2 \\ --dimensions Name=DBInstanceIdentifier,Value=modernized-mysql-db B∆∞·ªõc 7: Testing v√† Validation 7.1. Test connection t·ª´ API wrapper # Update API wrapper .env file cat \u0026gt; /home/ec2-user/api-wrapper/.env \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Database Configuration DB_HOST=\u0026lt;rds-endpoint\u0026gt; DB_PORT=3306 DB_USER=app_user DB_PASSWORD=SecureAppPassword123! DB_NAME=modernized_db # Flask Configuration FLASK_ENV=production FLASK_DEBUG=False SECRET_KEY=your-secret-key-here # AWS Configuration AWS_REGION=us-east-1 LOG_GROUP_NAME=api-wrapper-logs EOF # Restart API wrapper sudo systemctl restart api-wrapper # Test connection curl http://\u0026lt;api-server-ip\u0026gt;:5000/health 7.2. Performance testing # Create test script cat \u0026gt; /home/ec2-user/test_rds.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import pymysql import time import statistics # Database connection connection = pymysql.connect( host=\u0026#39;\u0026lt;rds-endpoint\u0026gt;\u0026#39;, user=\u0026#39;app_user\u0026#39;, password=\u0026#39;SecureAppPassword123!\u0026#39;, database=\u0026#39;modernized_db\u0026#39; ) def test_query_performance(): query_times = [] for i in range(10): start_time = time.time() with connection.cursor() as cursor: cursor.execute(\u0026#34;SELECT COUNT(*) FROM customers\u0026#34;) result = cursor.fetchone() end_time = time.time() query_times.append(end_time - start_time) print(f\u0026#34;Average query time: {statistics.mean(query_times):.4f} seconds\u0026#34;) print(f\u0026#34;Min query time: {min(query_times):.4f} seconds\u0026#34;) print(f\u0026#34;Max query time: {max(query_times):.4f} seconds\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: test_query_performance() connection.close() EOF # Run test cd /home/ec2-user/api-wrapper source venv/bin/activate python3 /home/ec2-user/test_rds.py B∆∞·ªõc 8: Backup v√† Recovery Testing 8.1. Test point-in-time recovery # Create test data mysql -h \u0026lt;rds-endpoint\u0026gt; -u admin -p modernized_db \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; INSERT INTO customers (name, email, phone, address) VALUES (\u0026#39;Test Customer 1\u0026#39;, \u0026#39;test1@example.com\u0026#39;, \u0026#39;0123456789\u0026#39;, \u0026#39;Test Address 1\u0026#39;), (\u0026#39;Test Customer 2\u0026#39;, \u0026#39;test2@example.com\u0026#39;, \u0026#39;0987654321\u0026#39;, \u0026#39;Test Address 2\u0026#39;); EOF # Note the current time echo \u0026#34;Current time: $(date)\u0026#34; # Create point-in-time restore aws rds restore-db-instance-to-point-in-time \\ --source-db-instance-identifier modernized-mysql-db \\ --target-db-instance-identifier modernized-mysql-db-restored \\ --restore-time $(date -u -d \u0026#39;5 minutes ago\u0026#39; +%Y-%m-%dT%H:%M:%S.000Z) 8.2. Test snapshot restore # Create snapshot aws rds create-db-snapshot \\ --db-instance-identifier modernized-mysql-db \\ --db-snapshot-identifier test-snapshot-$(date +%Y%m%d-%H%M%S) # Restore from snapshot aws rds restore-db-instance-from-db-snapshot \\ --db-instance-identifier modernized-mysql-db-from-snapshot \\ --db-snapshot-identifier test-snapshot-$(date +%Y%m%d-%H%M%S) Troubleshooting Common Issues Cannot connect to RDS:\n# Check security group rules aws ec2 describe-security-groups --group-ids \u0026lt;security-group-id\u0026gt; # Check RDS instance status aws rds describe-db-instances --db-instance-identifier modernized-mysql-db Performance issues:\n# Check CloudWatch metrics aws cloudwatch get-metric-statistics \\ --namespace AWS/RDS \\ --metric-name CPUUtilization \\ --dimensions Name=DBInstanceIdentifier,Value=modernized-mysql-db \\ --start-time $(date -u -d \u0026#39;1 hour ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Average Storage issues:\n# Check storage metrics aws cloudwatch get-metric-statistics \\ --namespace AWS/RDS \\ --metric-name FreeStorageSpace \\ --dimensions Name=DBInstanceIdentifier,Value=modernized-mysql-db \\ --start-time $(date -u -d \u0026#39;1 hour ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Average Useful Commands # Check RDS instance status aws rds describe-db-instances \\ --db-instance-identifier modernized-mysql-db \\ --query \u0026#39;DBInstances[0].DBInstanceStatus\u0026#39; # Get RDS endpoint aws rds describe-db-instances \\ --db-instance-identifier modernized-mysql-db \\ --query \u0026#39;DBInstances[0].Endpoint.Address\u0026#39; \\ --output text # List all snapshots aws rds describe-db-snapshots \\ --db-instance-identifier modernized-mysql-db K·∫øt qu·∫£: B·∫°n ƒë√£ thi·∫øt l·∫≠p th√†nh c√¥ng Amazon RDS MySQL instance v·ªõi c√°c t√≠nh nƒÉng b·∫£o m·∫≠t, backup, monitoring v√† performance optimization. Database n√†y s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ thay th·∫ø h·ªá th·ªëng legacy trong c√°c b∆∞·ªõc ti·∫øp theo.\n"
},
{
	"uri": "//localhost:1313/en/5-cloudwatch/",
	"title": "üìä Chapter 5: Monitoring with Amazon CloudWatch",
	"tags": [],
	"description": "",
	"content": "üéØ Objectives In this chapter, you will learn how to use Amazon CloudWatch to monitor the performance of containers running on ECS Fargate. Steps include:\nMonitor system metrics (CPU, memory, network) Create alarms Build visual dashboards (Optional) View logs for troubleshooting 1. Monitor metrics with CloudWatch Metrics Steps: Access AWS Console ‚Üí CloudWatch ‚Üí Metrics Find your ECS Cluster ‚Üí select metrics to monitor: Metric Meaning CPUUtilization CPU usage percentage MemoryUtilization Memory usage 2. Create alerts with CloudWatch Alarm Example: Alert when CPU \u0026gt; 80% for 5 minutes Go to CloudWatch ‚Üí Alarms ‚Üí Create Alarm Select metric: CPUUtilization Select cluster ‚Üí service to monitor Set conditions: Threshold: Greater than 80 Evaluation: 5 minutes Optional: send alerts via SNS or email Preview configuration ‚Üí select \u0026ldquo;Create Alarm\u0026rdquo; Tip: Create additional alarms for MemoryUtilization if you suspect memory leaks.\n3. Create overall monitoring dashboard Go to CloudWatch ‚Üí Dashboards ‚Üí Create Dashboard Name example: ecs-monitoring-dashboard Add the following widgets: Widget Type CPUUtilization (FE + BE) Line graph MemoryUtilization Line graph Alarm status Text or Alarm widget Save and use for visual monitoring 4. Check container logs If you need to check errors:\nGo to CloudWatch ‚Üí Logs ‚Üí Log groups Select log groups to view Click latest log stream ‚Üí view detailed logs üîß Log driver is configured by default in task definition from previous step.\n‚úÖ Conclusion Using CloudWatch helps you monitor, alert, and visualize ECS service performance. This is an essential DevOps tool to ensure applications run stably and respond promptly when issues occur.\n"
},
{
	"uri": "//localhost:1313/5-cloudwatch/",
	"title": "üìä Ch∆∞∆°ng 5: Monitoring v·ªõi Amazon CloudWatch",
	"tags": [],
	"description": "",
	"content": "üéØ M·ª•c ti√™u Trong ch∆∞∆°ng n√†y, b·∫°n s·∫Ω h·ªçc c√°ch s·ª≠ d·ª•ng Amazon CloudWatch ƒë·ªÉ gi√°m s√°t hi·ªáu nƒÉng c·ªßa c√°c container ch·∫°y tr√™n ECS Fargate. C√°c b∆∞·ªõc bao g·ªìm:\nTheo d√µi ch·ªâ s·ªë h·ªá th·ªëng (CPU, memory, network) T·∫°o c·∫£nh b√°o (alarm) X√¢y d·ª±ng dashboard tr·ª±c quan (Tu·ª≥ ch·ªçn) Xem log ƒë·ªÉ ch·∫©n ƒëo√°n s·ª± c·ªë 1. Theo d√µi ch·ªâ s·ªë v·ªõi CloudWatch Metrics C√°c b∆∞·ªõc: Truy c·∫≠p AWS Console ‚Üí CloudWatch ‚Üí Metrics T√¨m ECS Cluster c·ªßa b·∫°n ‚Üí ch·ªçn c√°c ch·ªâ s·ªë c·∫ßn theo d√µi: Metric √ù nghƒ©a CPUUtilization T·ª∑ l·ªá CPU ƒëang s·ª≠ d·ª•ng MemoryUtilization B·ªô nh·ªõ s·ª≠ d·ª•ng 2. T·∫°o c·∫£nh b√°o v·ªõi CloudWatch Alarm V√≠ d·ª•: C·∫£nh b√°o khi CPU \u0026gt; 80% trong 5 ph√∫t V√†o CloudWatch ‚Üí Alarms ‚Üí Create Alarm Ch·ªçn metric: CPUUtilization Ch·ªçn cluster ‚Üí service c·∫ßn gi√°m s√°t ƒê·∫∑t ƒëi·ªÅu ki·ªán: Threshold: Greater than 80 Evaluation: 5 minutes T√πy ch·ªçn: g·ª≠i c·∫£nh b√°o qua SNS ho·∫∑c email Preview c·∫ßu h√¨nh ‚Üí ch·ªçn \u0026ldquo;Create Alarm\u0026rdquo; G·ª£i √Ω: T·∫°o th√™m alarm cho MemoryUtilization n·∫øu b·∫°n nghi ng·ªù c√≥ r√≤ r·ªâ b·ªô nh·ªõ (memory leak).\n3. T·∫°o Dashboard gi√°m s√°t t·ªïng qu√°t V√†o CloudWatch ‚Üí Dashboards ‚Üí Create Dashboard ƒê·∫∑t t√™n v√≠ d·ª•: ecs-monitoring-dashboard Th√™m c√°c widget sau: Widget Lo·∫°i CPUUtilization (FE + BE) Line graph MemoryUtilization Line graph Alarm status Text or Alarm widget L∆∞u l·∫°i v√† s·ª≠ d·ª•ng ƒë·ªÉ gi√°m s√°t tr·ª±c quan 4. Ki·ªÉm tra log container N·∫øu c·∫ßn ki·ªÉm tra l·ªói:\nV√†o CloudWatch ‚Üí Logs ‚Üí Log groups Ch·ªçn log groups mu·ªën xem Click log stream m·ªõi nh·∫•t ‚Üí xem log chi ti·∫øt üîß Log driver ƒë∆∞·ª£c c·∫•u h√¨nh m·∫∑c ƒë·ªãnh trong task definition ·ªü b∆∞·ªõc tr∆∞·ªõc.\n‚úÖ K·∫øt lu·∫≠n S·ª≠ d·ª•ng CloudWatch gi√∫p b·∫°n theo d√µi, c·∫£nh b√°o v√† tr·ª±c quan h√≥a hi·ªáu nƒÉng ECS service. ƒê√¢y l√† c√¥ng c·ª• DevOps kh√¥ng th·ªÉ thi·∫øu ƒë·ªÉ ƒë·∫£m b·∫£o ·ª©ng d·ª•ng ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh v√† ph·∫£n ·ª©ng k·ªãp th·ªùi khi c√≥ s·ª± c·ªë.\n"
},
{
	"uri": "//localhost:1313/vi/5-cloudwatch/",
	"title": "üìä Ch∆∞∆°ng 5: Monitoring v·ªõi Amazon CloudWatch",
	"tags": [],
	"description": "",
	"content": "üéØ M·ª•c ti√™u Trong ch∆∞∆°ng n√†y, b·∫°n s·∫Ω h·ªçc c√°ch s·ª≠ d·ª•ng Amazon CloudWatch ƒë·ªÉ gi√°m s√°t hi·ªáu nƒÉng c·ªßa c√°c container ch·∫°y tr√™n ECS Fargate. C√°c b∆∞·ªõc bao g·ªìm:\nTheo d√µi ch·ªâ s·ªë h·ªá th·ªëng (CPU, memory, network) T·∫°o c·∫£nh b√°o (alarm) X√¢y d·ª±ng dashboard tr·ª±c quan (Tu·ª≥ ch·ªçn) Xem log ƒë·ªÉ ch·∫©n ƒëo√°n s·ª± c·ªë 1. Theo d√µi ch·ªâ s·ªë v·ªõi CloudWatch Metrics C√°c b∆∞·ªõc: Truy c·∫≠p AWS Console ‚Üí CloudWatch ‚Üí Metrics T√¨m ECS Cluster c·ªßa b·∫°n ‚Üí ch·ªçn c√°c ch·ªâ s·ªë c·∫ßn theo d√µi: Metric √ù nghƒ©a CPUUtilization T·ª∑ l·ªá CPU ƒëang s·ª≠ d·ª•ng MemoryUtilization B·ªô nh·ªõ s·ª≠ d·ª•ng 2. T·∫°o c·∫£nh b√°o v·ªõi CloudWatch Alarm V√≠ d·ª•: C·∫£nh b√°o khi CPU \u0026gt; 80% trong 5 ph√∫t V√†o CloudWatch ‚Üí Alarms ‚Üí Create Alarm Ch·ªçn metric: CPUUtilization Ch·ªçn cluster ‚Üí service c·∫ßn gi√°m s√°t ƒê·∫∑t ƒëi·ªÅu ki·ªán: Threshold: Greater than 80 Evaluation: 5 minutes T√πy ch·ªçn: g·ª≠i c·∫£nh b√°o qua SNS ho·∫∑c email Preview c·∫ßu h√¨nh ‚Üí ch·ªçn \u0026ldquo;Create Alarm\u0026rdquo; G·ª£i √Ω: T·∫°o th√™m alarm cho MemoryUtilization n·∫øu b·∫°n nghi ng·ªù c√≥ r√≤ r·ªâ b·ªô nh·ªõ (memory leak).\n3. T·∫°o Dashboard gi√°m s√°t t·ªïng qu√°t V√†o CloudWatch ‚Üí Dashboards ‚Üí Create Dashboard ƒê·∫∑t t√™n v√≠ d·ª•: ecs-monitoring-dashboard Th√™m c√°c widget sau: Widget Lo·∫°i CPUUtilization (FE + BE) Line graph MemoryUtilization Line graph Alarm status Text or Alarm widget L∆∞u l·∫°i v√† s·ª≠ d·ª•ng ƒë·ªÉ gi√°m s√°t tr·ª±c quan 4. Ki·ªÉm tra log container N·∫øu c·∫ßn ki·ªÉm tra l·ªói:\nV√†o CloudWatch ‚Üí Logs ‚Üí Log groups Ch·ªçn log groups mu·ªën xem Click log stream m·ªõi nh·∫•t ‚Üí xem log chi ti·∫øt üîß Log driver ƒë∆∞·ª£c c·∫•u h√¨nh m·∫∑c ƒë·ªãnh trong task definition ·ªü b∆∞·ªõc tr∆∞·ªõc.\n‚úÖ K·∫øt lu·∫≠n S·ª≠ d·ª•ng CloudWatch gi√∫p b·∫°n theo d√µi, c·∫£nh b√°o v√† tr·ª±c quan h√≥a hi·ªáu nƒÉng ECS service. ƒê√¢y l√† c√¥ng c·ª• DevOps kh√¥ng th·ªÉ thi·∫øu ƒë·ªÉ ƒë·∫£m b·∫£o ·ª©ng d·ª•ng ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh v√† ph·∫£n ·ª©ng k·ªãp th·ªùi khi c√≥ s·ª± c·ªë.\n"
},
{
	"uri": "//localhost:1313/en/6-github-actions/",
	"title": "üîÅ Chapter 6: Automate everything with GitHub Actions",
	"tags": [],
	"description": "",
	"content": "üéØ Objectives After this chapter, you will set up a CI/CD process that automates everything when pushing code to GitHub:\nBuild images for frontend and backend Push images to Amazon ECR Deploy containers to ECS Fargate Log and check status (Optional) Rollback if errors occur 1. Set up secrets in GitHub Go to GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions, add variables:\nName Value AWS_ACCESS_KEY_ID Access Key of IAM user/role AWS_SECRET_ACCESS_KEY Corresponding secret key AWS_REGION ap-southeast-1 AWS_ACCOUNT_ID AWS account ID üéØ IAM user should have permissions: AmazonEC2ContainerRegistryFullAccess, AmazonECS_FullAccess, CloudWatchLogsFullAccess\n2. Create file .github/workflows/ci-cd.yml name: CI/CD Pipeline on: push: branches: - main env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v3 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR uses: aws-actions/amazon-ecr-login@v1 - name: Build and Push Frontend Image run: | docker build -t frontend-app ./frontend docker tag frontend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest - name: Build and Push Backend Image run: | docker build -t backend-app ./backend docker tag backend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest - name: Deploy to ECS run: | aws ecs update-service --cluster workshop-cluster --service frontend-service --force-new-deployment aws ecs update-service --cluster workshop-cluster --service backend-service --force-new-deployment - name: Check ECS Service Status run: | aws ecs describe-services --cluster workshop-cluster \\ --services frontend-service backend-service 3. Logging and status checking Check container logs: Go to CloudWatch ‚Üí Log groups ‚Üí View log stream Check ECS status: aws ecs describe-services --cluster workshop-cluster --services frontend-service backend-service 4. Rollback (manual) When deployment fails, you can rollback by:\nRevert code ‚Üí Push again Or deploy old image from ECR (if tagged and saved previously) üì¶ Tip: Use tags :v1, :v2, :rollback,\u0026hellip; for easy rollback image control\n"
},
{
	"uri": "//localhost:1313/6-github-actions/",
	"title": "üîÅ Ch∆∞∆°ng 6: T·ª± ƒë·ªông h√≥a to√†n b·ªô v·ªõi GitHub Actions",
	"tags": [],
	"description": "",
	"content": "üéØ M·ª•c ti√™u Sau ch∆∞∆°ng n√†y, b·∫°n s·∫Ω thi·∫øt l·∫≠p quy tr√¨nh CI/CD t·ª± ƒë·ªông h√≥a to√†n b·ªô khi push code l√™n GitHub:\nBuild image cho frontend v√† backend Push image l√™n Amazon ECR Tri·ªÉn khai container l√™n ECS Fargate Ghi log v√† ki·ªÉm tra tr·∫°ng th√°i (Tu·ª≥ ch·ªçn) Rollback n·∫øu c√≥ l·ªói 1. Thi·∫øt l·∫≠p b√≠ m·∫≠t trong GitHub V√†o GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions, th√™m c√°c bi·∫øn:\nName Value AWS_ACCESS_KEY_ID Access Key c·ªßa IAM user/role AWS_SECRET_ACCESS_KEY Secret key t∆∞∆°ng ·ª©ng AWS_REGION ap-southeast-1 AWS_ACCOUNT_ID ID t√†i kho·∫£n AWS üéØ IAM user n√™n c√≥ quy·ªÅn: AmazonEC2ContainerRegistryFullAccess, AmazonECS_FullAccess, CloudWatchLogsFullAccess\n2. T·∫°o file .github/workflows/ci-cd.yml name: CI/CD Pipeline on: push: branches: - main env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v3 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR uses: aws-actions/amazon-ecr-login@v1 - name: Build and Push Frontend Image run: | docker build -t frontend-app ./frontend docker tag frontend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest - name: Build and Push Backend Image run: | docker build -t backend-app ./backend docker tag backend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest - name: Deploy to ECS run: | aws ecs update-service --cluster workshop-cluster --service frontend-service --force-new-deployment aws ecs update-service --cluster workshop-cluster --service backend-service --force-new-deployment - name: Check ECS Service Status run: | aws ecs describe-services --cluster workshop-cluster \\ --services frontend-service backend-service 3. Logging v√† ki·ªÉm tra tr·∫°ng th√°i Ki·ªÉm tra log container: V√†o CloudWatch ‚Üí Log groups ‚Üí Xem log stream Ki·ªÉm tra tr·∫°ng th√°i ECS: aws ecs describe-services --cluster workshop-cluster --services frontend-service backend-service 4. Rollback (th·ªß c√¥ng) Khi deploy l·ªói, b·∫°n c√≥ th·ªÉ rollback b·∫±ng c√°ch:\nRevert code ‚Üí Push l·∫°i Ho·∫∑c deploy image c≈© t·ª´ ECR (n·∫øu ƒë√£ ƒë∆∞·ª£c tag v√† l∆∞u tr∆∞·ªõc ƒë√≥) üì¶ G·ª£i √Ω: S·ª≠ d·ª•ng tag :v1, :v2, :rollback,\u0026hellip; ƒë·ªÉ d·ªÖ ki·ªÉm so√°t rollback image\n"
},
{
	"uri": "//localhost:1313/vi/6-github-actions/",
	"title": "üîÅ Ch∆∞∆°ng 6: T·ª± ƒë·ªông h√≥a to√†n b·ªô v·ªõi GitHub Actions",
	"tags": [],
	"description": "",
	"content": "üéØ M·ª•c ti√™u Sau ch∆∞∆°ng n√†y, b·∫°n s·∫Ω thi·∫øt l·∫≠p quy tr√¨nh CI/CD t·ª± ƒë·ªông h√≥a to√†n b·ªô khi push code l√™n GitHub:\nBuild image cho frontend v√† backend Push image l√™n Amazon ECR Tri·ªÉn khai container l√™n ECS Fargate Ghi log v√† ki·ªÉm tra tr·∫°ng th√°i (Tu·ª≥ ch·ªçn) Rollback n·∫øu c√≥ l·ªói 1. Thi·∫øt l·∫≠p b√≠ m·∫≠t trong GitHub V√†o GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions, th√™m c√°c bi·∫øn:\nName Value AWS_ACCESS_KEY_ID Access Key c·ªßa IAM user/role AWS_SECRET_ACCESS_KEY Secret key t∆∞∆°ng ·ª©ng AWS_REGION ap-southeast-1 AWS_ACCOUNT_ID ID t√†i kho·∫£n AWS üéØ IAM user n√™n c√≥ quy·ªÅn: AmazonEC2ContainerRegistryFullAccess, AmazonECS_FullAccess, CloudWatchLogsFullAccess\n2. T·∫°o file .github/workflows/ci-cd.yml name: CI/CD Pipeline on: push: branches: - main env: AWS_REGION: ${{ secrets.AWS_REGION }} AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v3 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v2 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR uses: aws-actions/amazon-ecr-login@v1 - name: Build and Push Frontend Image run: | docker build -t frontend-app ./frontend docker tag frontend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/frontend-app:latest - name: Build and Push Backend Image run: | docker build -t backend-app ./backend docker tag backend-app:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/backend-app:latest - name: Deploy to ECS run: | aws ecs update-service --cluster workshop-cluster --service frontend-service --force-new-deployment aws ecs update-service --cluster workshop-cluster --service backend-service --force-new-deployment - name: Check ECS Service Status run: | aws ecs describe-services --cluster workshop-cluster \\ --services frontend-service backend-service 3. Logging v√† ki·ªÉm tra tr·∫°ng th√°i Ki·ªÉm tra log container: V√†o CloudWatch ‚Üí Log groups ‚Üí Xem log stream Ki·ªÉm tra tr·∫°ng th√°i ECS: aws ecs describe-services --cluster workshop-cluster --services frontend-service backend-service 4. Rollback (th·ªß c√¥ng) Khi deploy l·ªói, b·∫°n c√≥ th·ªÉ rollback b·∫±ng c√°ch:\nRevert code ‚Üí Push l·∫°i Ho·∫∑c deploy image c≈© t·ª´ ECR (n·∫øu ƒë√£ ƒë∆∞·ª£c tag v√† l∆∞u tr∆∞·ªõc ƒë√≥) üì¶ G·ª£i √Ω: S·ª≠ d·ª•ng tag :v1, :v2, :rollback,\u0026hellip; ƒë·ªÉ d·ªÖ ki·ªÉm so√°t rollback image\n"
},
{
	"uri": "//localhost:1313/7-cleanup/",
	"title": "üßπ Ch∆∞∆°ng 7: Cleanup &amp; t·ªïng k·∫øt",
	"tags": [],
	"description": "",
	"content": "Cleanup X√≥a ECS service v√† task C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console.\nƒêi·ªÅu h∆∞·ªõng ƒë·∫øn ECS (Elastic Container Service).\nX√≥a c√°c service:\nfrontend-service backend-service X√≥a cluster n·∫øu kh√¥ng c√≤n s·ª≠ d·ª•ng.\nX√≥a ECR image C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn ECR (Elastic Container Registry). X√≥a c√°c image trong repository: frontend-app backend-app X√≥a log tr√™n CloudWatch C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn CloudWatch \u0026gt; Logs. X√≥a c√°c log group: /aws/ecs/workshop-cluster/frontend-app /aws/ecs/workshop-cluster/backend-app C·∫£nh b√°o: ƒê·∫£m b·∫£o b·∫°n kh√¥ng c·∫ßn d·ªØ li·ªáu tr∆∞·ªõc khi x√≥a.\nT·ªïng k·∫øt Ki·∫øn th·ª©c ƒë√£ h·ªçc Quy tr√¨nh CI/CD c∆° b·∫£n. Docker h√≥a ·ª©ng d·ª•ng frontend v√† backend. S·ª≠ d·ª•ng c√°c d·ªãch v·ª• AWS nh∆∞ ECR, ECS Fargate, v√† CloudWatch. T·ª± ƒë·ªông h√≥a to√†n b·ªô quy tr√¨nh v·ªõi GitHub Actions. B∆∞·ªõc ti·∫øp theo √Åp d·ª•ng ki·∫øn th·ª©c v√†o d·ª± √°n th·ª±c t·∫ø. T√¨m hi·ªÉu th√™m v·ªÅ c√°c d·ªãch v·ª• AWS kh√°c nh∆∞ Lambda, API Gateway. N√¢ng cao k·ªπ nƒÉng DevOps b·∫±ng c√°ch tri·ªÉn khai c√°c h·ªá th·ªëng ph·ª©c t·∫°p h∆°n. Tip: Lu√¥n ki·ªÉm tra t√†i nguy√™n AWS ƒë·ªÉ tr√°nh chi ph√≠ kh√¥ng c·∫ßn thi·∫øt.\n"
},
{
	"uri": "//localhost:1313/vi/7-cleanup/",
	"title": "üßπ Ch∆∞∆°ng 7: Cleanup &amp; t·ªïng k·∫øt",
	"tags": [],
	"description": "",
	"content": "Cleanup X√≥a ECS service v√† task C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console.\nƒêi·ªÅu h∆∞·ªõng ƒë·∫øn ECS (Elastic Container Service).\nX√≥a c√°c service:\nfrontend-service backend-service X√≥a cluster n·∫øu kh√¥ng c√≤n s·ª≠ d·ª•ng.\nX√≥a ECR image C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn ECR (Elastic Container Registry). X√≥a c√°c image trong repository: frontend-app backend-app X√≥a log tr√™n CloudWatch C√°c b∆∞·ªõc th·ª±c hi·ªán Truy c·∫≠p AWS Management Console. ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn CloudWatch \u0026gt; Logs. X√≥a c√°c log group: /aws/ecs/workshop-cluster/frontend-app /aws/ecs/workshop-cluster/backend-app C·∫£nh b√°o: ƒê·∫£m b·∫£o b·∫°n kh√¥ng c·∫ßn d·ªØ li·ªáu tr∆∞·ªõc khi x√≥a.\nT·ªïng k·∫øt Ki·∫øn th·ª©c ƒë√£ h·ªçc Quy tr√¨nh CI/CD c∆° b·∫£n. Docker h√≥a ·ª©ng d·ª•ng frontend v√† backend. S·ª≠ d·ª•ng c√°c d·ªãch v·ª• AWS nh∆∞ ECR, ECS Fargate, v√† CloudWatch. T·ª± ƒë·ªông h√≥a to√†n b·ªô quy tr√¨nh v·ªõi GitHub Actions. B∆∞·ªõc ti·∫øp theo √Åp d·ª•ng ki·∫øn th·ª©c v√†o d·ª± √°n th·ª±c t·∫ø. T√¨m hi·ªÉu th√™m v·ªÅ c√°c d·ªãch v·ª• AWS kh√°c nh∆∞ Lambda, API Gateway. N√¢ng cao k·ªπ nƒÉng DevOps b·∫±ng c√°ch tri·ªÉn khai c√°c h·ªá th·ªëng ph·ª©c t·∫°p h∆°n. Tip: Lu√¥n ki·ªÉm tra t√†i nguy√™n AWS ƒë·ªÉ tr√°nh chi ph√≠ kh√¥ng c·∫ßn thi·∫øt.\n"
},
{
	"uri": "//localhost:1313/en/7-cleanup/",
	"title": "üßπ Chapter 7: Cleanup &amp; Summary",
	"tags": [],
	"description": "",
	"content": "Cleanup Delete ECS service and task Steps to follow Access AWS Management Console.\nNavigate to ECS (Elastic Container Service).\nDelete services:\nfrontend-service backend-service Delete cluster if no longer used.\nDelete ECR images Steps to follow Access AWS Management Console. Navigate to ECR (Elastic Container Registry). Delete images in repositories: frontend-app backend-app Delete logs on CloudWatch Steps to follow Access AWS Management Console. Navigate to CloudWatch \u0026gt; Logs. Delete log groups: /aws/ecs/workshop-cluster/frontend-app /aws/ecs/workshop-cluster/backend-app Warning: Make sure you don\u0026rsquo;t need the data before deleting.\nSummary Knowledge learned Basic CI/CD process. Dockerizing frontend and backend applications. Using AWS services like ECR, ECS Fargate, and CloudWatch. Automating the entire process with GitHub Actions. Next steps Apply knowledge to real projects. Learn more about other AWS services like Lambda, API Gateway. Improve DevOps skills by deploying more complex systems. Tip: Always check AWS resources to avoid unnecessary costs.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/",
	"title": "Workshop: Deploy applications with ECS Fargate and CI/CD",
	"tags": [],
	"description": "",
	"content": ""
}]